//! Response types for the Realtime API.
//!
//! This module contains types for response configuration and the response
//! object returned by the API during streaming.

use serde::{Deserialize, Serialize};

use super::{
    conversation::ConversationItem,
    session::{
        AudioOutputConfig, MaxResponseOutputTokens, Modality, Prompt, ToolChoice, ToolDefinition,
    },
};

// ============================================================================
// Response Object (Server Response)
// ============================================================================

fn response_object_type() -> String {
    "realtime.response".to_string()
}

/// A response object returned in `response.created` and `response.done` events.
///
/// Represents the state of an in-progress or completed response.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Response {
    /// The unique ID of the response (e.g., `resp_1234`)
    pub id: String,
    /// The object type (always "realtime.response")
    #[serde(default = "response_object_type")]
    pub object: String,
    /// The final status of the response
    pub status: ResponseStatus,
    /// Additional details about the status
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status_details: Option<ResponseStatusDetails>,
    /// The list of output items generated by the response
    pub output: Vec<ConversationItem>,
    /// Additional metadata
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<serde_json::Value>,
    /// Configuration for audio output
    #[serde(skip_serializing_if = "Option::is_none")]
    pub audio: Option<ResponseAudioConfig>,
    /// Usage statistics for the response (corresponds to billing)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub usage: Option<ResponseUsage>,
    /// Which conversation the response is added to.
    /// If `auto`, will be an id like `conv_1234`. If `none`, will be `null`.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub conversation_id: Option<String>,
    /// The set of modalities the model used to respond (e.g., `["audio"]`, `["text"]`)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub output_modalities: Option<Vec<Modality>>,
    /// Maximum number of output tokens for a single assistant response
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_output_tokens: Option<MaxResponseOutputTokens>,
}

impl Response {
    /// Check if the response is still in progress
    pub fn is_in_progress(&self) -> bool {
        self.status == ResponseStatus::InProgress
    }

    /// Check if the response completed successfully
    pub fn is_completed(&self) -> bool {
        self.status == ResponseStatus::Completed
    }

    /// Check if the response failed or was cancelled
    pub fn is_failed(&self) -> bool {
        matches!(
            self.status,
            ResponseStatus::Failed | ResponseStatus::Cancelled
        )
    }

    /// Get all function calls from the response output
    pub fn function_calls(&self) -> impl Iterator<Item = &ConversationItem> {
        self.output.iter().filter(|item| item.is_function_call())
    }
}

// ============================================================================
// Response Configuration (Client Request)
// ============================================================================

/// Configuration for creating a response.
///
/// Used in `response.create` events to customize the response.
/// Matches the GA `RealtimeResponseCreateParams` schema.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ResponseConfig {
    /// The set of modalities the model can respond with (e.g., `["audio"]`, `["text"]`).
    /// Audio output always includes a text transcript. Setting to `["text"]` disables audio.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub output_modalities: Option<Vec<Modality>>,

    /// System instructions prepended to model calls. Can guide response content/format
    /// (e.g. "be succinct", "act friendly") and audio behavior (e.g. "talk quickly").
    #[serde(skip_serializing_if = "Option::is_none")]
    pub instructions: Option<String>,

    /// Configuration for audio input and output (format, voice).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub audio: Option<ResponseAudioConfig>,

    /// Tools available to the model (function tools or MCP tools).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tools: Option<Vec<ToolDefinition>>,

    /// How the model chooses tools. Can be a mode string or force a specific function/MCP tool.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tool_choice: Option<ToolChoice>,

    /// Maximum output tokens for a single assistant response, inclusive of tool calls.
    /// Integer between 1 and 4096, or `inf` for maximum available. Defaults to `inf`.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_output_tokens: Option<MaxResponseOutputTokens>,

    /// Controls which conversation the response is added to.
    /// `auto` (default) adds to default conversation. `none` creates an out-of-band response.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub conversation: Option<ResponseConversation>,

    /// Additional metadata for the response.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<serde_json::Value>,

    /// Prompt template reference.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prompt: Option<Prompt>,

    /// Input items to include in the prompt. Creates a new context for this response
    /// instead of using the default conversation. Empty array `[]` clears the context.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub input: Option<Vec<ConversationItem>>,
}

// ============================================================================
// Supporting Types
// ============================================================================

// --- Response Status ---

/// Status of a response.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ResponseStatus {
    /// Response is being generated
    InProgress,
    /// Response completed successfully
    Completed,
    /// Response was cancelled
    Cancelled,
    /// Response generation was interrupted
    Incomplete,
    /// Response failed due to an error
    Failed,
}

// --- Response Status Details ---

/// Reason a response did not complete.
///
/// For `cancelled`: `turn_detected` or `client_cancelled`.
/// For `incomplete`: `max_output_tokens` or `content_filter`.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum StatusReason {
    /// Server VAD detected a new start of speech
    TurnDetected,
    /// Client sent a cancel event
    ClientCancelled,
    /// Response hit the max output token limit
    MaxOutputTokens,
    /// Server-side safety filter activated
    ContentFilter,
}

/// Details about why a response ended.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ResponseStatusDetails {
    /// Response completed normally
    Completed,
    /// Response was cancelled
    Cancelled {
        /// Reason for cancellation
        #[serde(skip_serializing_if = "Option::is_none")]
        reason: Option<StatusReason>,
    },
    /// Response was incomplete
    Incomplete {
        /// Reason for incompleteness
        #[serde(skip_serializing_if = "Option::is_none")]
        reason: Option<StatusReason>,
    },
    /// Response failed with an error
    Failed {
        /// Error details
        #[serde(skip_serializing_if = "Option::is_none")]
        error: Option<ResponseError>,
    },
}

/// Error details for a failed response.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResponseError {
    /// Error type
    #[serde(rename = "type")]
    pub error_type: String,
    /// Error code
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    /// Error message
    pub message: String,
}

// --- Audio Configuration ---

/// Audio configuration for response creation (output only).
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ResponseAudioConfig {
    /// Output audio configuration (format, voice)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub output: Option<AudioOutputConfig>,
}

/// Conversation context for response generation.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ResponseConversation {
    /// Use items from conversation (auto mode)
    Auto,
    /// Use none of the conversation items
    None,
}

// --- Response Content Part ---

/// Content part in response streaming events.
///
/// This is a simpler type than `ContentPart`, used in `response.content_part.added`
/// and `response.content_part.done` events. Only supports "text" and "audio" types.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ResponseContentPart {
    /// Text content
    Text {
        /// The text content
        #[serde(skip_serializing_if = "Option::is_none")]
        text: Option<String>,
    },
    /// Audio content
    Audio {
        /// Base64-encoded audio data
        #[serde(skip_serializing_if = "Option::is_none")]
        audio: Option<String>,
        /// The transcript of the audio
        #[serde(skip_serializing_if = "Option::is_none")]
        transcript: Option<String>,
    },
}

// --- Usage Statistics ---

/// Token usage statistics for a response.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ResponseUsage {
    /// Total tokens used
    #[serde(default)]
    pub total_tokens: u32,
    /// Input tokens used
    #[serde(default)]
    pub input_tokens: u32,
    /// Output tokens generated
    #[serde(default)]
    pub output_tokens: u32,
    /// Detailed input token breakdown
    #[serde(skip_serializing_if = "Option::is_none")]
    pub input_token_details: Option<InputTokenDetails>,
    /// Detailed output token breakdown
    #[serde(skip_serializing_if = "Option::is_none")]
    pub output_token_details: Option<OutputTokenDetails>,
}

/// Detailed breakdown of input tokens.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct InputTokenDetails {
    /// Tokens from cached content
    #[serde(default)]
    pub cached_tokens: u32,
    /// Tokens from text content
    #[serde(default)]
    pub text_tokens: u32,
    /// Tokens from image content
    #[serde(default)]
    pub image_tokens: u32,
    /// Tokens from audio content
    #[serde(default)]
    pub audio_tokens: u32,
    /// Breakdown of cached tokens by type
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cached_tokens_details: Option<CachedTokensDetails>,
}

/// Breakdown of cached tokens by type.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct CachedTokensDetails {
    /// Cached text tokens
    #[serde(default)]
    pub text_tokens: u32,
    /// Cached image tokens
    #[serde(default)]
    pub image_tokens: u32,
    /// Cached audio tokens
    #[serde(default)]
    pub audio_tokens: u32,
}

/// Detailed breakdown of output tokens.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct OutputTokenDetails {
    /// Tokens for text output
    #[serde(default)]
    pub text_tokens: u32,
    /// Tokens for audio output
    #[serde(default)]
    pub audio_tokens: u32,
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_response_status_serialization() {
        assert_eq!(
            serde_json::to_string(&ResponseStatus::InProgress).unwrap(),
            "\"in_progress\""
        );
        assert_eq!(
            serde_json::to_string(&ResponseStatus::Completed).unwrap(),
            "\"completed\""
        );
        assert_eq!(
            serde_json::to_string(&ResponseStatus::Cancelled).unwrap(),
            "\"cancelled\""
        );
    }

    #[test]
    fn test_response_config_default() {
        let config = ResponseConfig::default();
        let json = serde_json::to_string(&config).unwrap();
        assert_eq!(json, "{}");
    }

    #[test]
    fn test_response_config_with_options() {
        let config = ResponseConfig {
            output_modalities: Some(vec![Modality::Text, Modality::Audio]),
            instructions: Some("Be concise".to_string()),
            ..Default::default()
        };
        let json = serde_json::to_string(&config).unwrap();
        assert!(json.contains("\"output_modalities\""));
        assert!(json.contains("\"instructions\""));
    }

    #[test]
    fn test_response_usage() {
        let usage = ResponseUsage {
            total_tokens: 100,
            input_tokens: 50,
            output_tokens: 50,
            input_token_details: Some(InputTokenDetails {
                cached_tokens: 10,
                text_tokens: 30,
                audio_tokens: 10,
                image_tokens: 0,
                cached_tokens_details: None,
            }),
            output_token_details: Some(OutputTokenDetails {
                text_tokens: 25,
                audio_tokens: 25,
            }),
        };
        let json = serde_json::to_string(&usage).unwrap();
        assert!(json.contains("\"total_tokens\":100"));
        assert!(json.contains("\"cached_tokens\":10"));
    }

    #[test]
    fn test_response_deserialization() {
        let json = r#"{
            "id": "resp_123",
            "object": "realtime.response",
            "status": "completed",
            "output": []
        }"#;
        let response: Response = serde_json::from_str(json).unwrap();
        assert_eq!(response.id, "resp_123");
        assert!(response.is_completed());
    }
}
